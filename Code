import bs4
from bs4 import BeautifulSoup
import pandas as pd
import requests
import re
from time import sleep
import math
import genderdecoder
import wordlists
import pyodbc




def html_soup_to_str(url):
    page = requests.get(url)
    soup = BeautifulSoup(page.text,"html.parser")
    string = str(soup)
    return(string)

def find_num_job_pages(url,start,stop):
    string = html_soup_to_str(url)
    find_start = string.find(start)
    find_stop = string.find(stop)
    count = string[find_start+len(start)+2:find_stop-2]
    jobs = int(count)
    pages = jobs/10
    pages = math.ceil(pages)
    return(pages)

def get_job_batch_urls(page_count, url_base):                                
    job_pages = []
    x=1
    for i in range(0, page_count):
        job_url = url_base + str(x)
        job_pages.append(job_url)
        x = x+1
    return(job_pages)

def get_all_job_hrefs(batch_list):
    job_urls = []
    for job_page in batch_list:
        string = html_soup_to_str(job_page)
        url1regex = re.compile(r'(\w\w\w\w\w\W\W\W\w\w\w\w\.\w\w\w\w\w\w\w\.\w\w\w\W\w\w\w\w\W\w\w\w\w\w\w\w\W\d\W\d\d\d\d\d\W\w\w\w\w\W\w\w\W\w\w)|(\w\w\w\w\w\W\W\W\w\w\w\w\.\w\w\w\w\w\w\w\.\w\w\w\W\w\w\w\w\W\w\w\w\w\w\w\w\W\d\W\d\d\d\d\W\w\w\w\w\W\w\w\W\w\w)')
        hrefs = url1regex.findall(string)
        for href in hrefs:
            job_urls.append(href)  
    hrefs = set(job_urls)
    return(hrefs)

def clean_hrefs(set_of_hrefs, start,stop):    
    hrefs=list(set_of_hrefs)
    href_list=[]
    for href in hrefs:
        string = str(href)
        find_start = string.find(start)
        find_stop = string.find(stop)        
        href_final = string[find_start:find_stop+len(stop)]
        href_list.append(href_final)
    return(href_list)



def get_info_from_hrefs(df,href_list):
    celgenejobsfinal = []
    for href in href_list:
        celgenejobs=[]
        num = (len(df) + 1) 
        hrefpage = requests.get(href)
        hrefsoup = BeautifulSoup(hrefpage.text, "html.parser")
    
        #job title
        h1s= hrefsoup.find(name="h1",attrs={"itemprop":"title"})
        celgenejobs.append(h1s.text)
    
    
        #location
        loc = hrefsoup.find(name= "li", attrs = {"itemprop":"jobLocation"})   
        try:
            celgenejobs.append(loc.text.strip())  
        except:
            loc="None"
            celgenejobs.append(loc)
    
        # Job category
        category = hrefsoup.find(name = "li" , attrs = {"itemprop":"occupationalCategory"})
        try:
            celgenejobs.append(category.text.strip())
        except:
            category="None"
            celgenejobs.append(category)
    
        # Requisition id
        reqid = hrefsoup.find(name = "li" , attrs = {"itemprop":"reqId"})
        try:
            celgenejobs.append(reqid.text.strip())
        except:
            reqid="None"
            celgenejobs.append(reqid)
    
        #Summary
        summary = hrefsoup.find(name="p")
        celgenejobs.append(summary.text)
        celgenejobsfinal.append(celgenejobs)
    
    return(celgenejobs_df)

def assess(ad_text):
    ad_text = ''.join([i if ord(i) < 128 else ' ' for i in ad_text])
    ad_text = re.sub("[\\s]", " ", ad_text, 0, 0)
    ad_text = re.sub("[\.\t\,\:;\(\)\.]", "", ad_text, 0, 0).split(" ")
    ad_text = [ad for ad in ad_text if ad != ""]
        
    masculine_coded_words = [adword for adword in ad_text
        for word in wordlists.masculine_coded_words
        if adword.startswith(word)]
    
    feminine_coded_words = [adword for adword in ad_text
        for word in wordlists.feminine_coded_words
        if adword.startswith(word)]
    
    if feminine_coded_words and not masculine_coded_words:
        result = "strongly feminine-coded"
    elif masculine_coded_words and not feminine_coded_words:
        result = "strongly masculine-coded"
    elif not masculine_coded_words and not feminine_coded_words:
        result = "neutral"
    else: 
        if len(feminine_coded_words) == len(masculine_coded_words):
            result = "neutral"
        if ((len(feminine_coded_words) / len(masculine_coded_words)) >= 2 and 
            len(feminine_coded_words) > 5):
            result = "strongly feminine-coded"
        if ((len(masculine_coded_words) / len(feminine_coded_words)) >= 2 and 
            len(masculine_coded_words) > 5):
            result = "strongly masculine-coded"
        if len(feminine_coded_words) > len(masculine_coded_words):
            result = "feminine-coded"
        if len(masculine_coded_words) > len(feminine_coded_words):
            result = "masculine-coded"
    
    if "feminine" in result:
        explanation = ("This job ad uses more words that are stereotypically feminine "
            "than words that are stereotypically masculine. Fortunately, the research "
            "suggests this will have only a slight effect on how appealing the job is "
            "to men, and will encourage women applicants.")
    elif "masculine" in result:
        explanation = ("This job ad uses more words that are stereotypically masculine "
            "than words that are stereotypically feminine. It risks putting women off "
            "applying, but will probably encourage men to apply.")
    elif not masculine_coded_words and not feminine_coded_words:
        explanation = ("This job ad doesn't use any words that are stereotypically "
            "masculine and stereotypically feminine. It probably won't be off-putting "
            "to men or women applicants.")
    else:
        explanation = ("This job ad uses an equal number of words that are "
            "stereotypically masculine and stereotypically feminine. It probably won't "
            "be off-putting to men or women applicants.")

    return {"result": result,
            "explanation": explanation,
            "masculine_coded_words": masculine_coded_words,
            "feminine_coded_words": feminine_coded_words
            } 



def summaryresults(summary):
    i=0
    length = int(len(summary))
    for i in range(0,length):
        jobdescription=str(summary[i])
        a=assess(jobdescription)
        results.append(a['result'])
        explanation.append(a['explanation'])
        male.append(a['masculine_coded_words'])
        female.append(a['feminine_coded_words'])
    resultslist=results
    explanationlist=explanation
    malelist=male
    femalelist=female
    
def join(df,table):
    df['req_id']=df['req_id'].astype(int)
    table['req_id']=table['req_id'].astype(int)

    # Getting the final table
    volume2 = table[['req_id','primary_loc','country','region','state','city','hiring_managers','recruiter','supervisory_org','franchise','job_profile','position_name','hr_partner']]
    final_table1 = pd.merge(df,volume2,how='left',on='req_id')
    nullfinal_table = final_table1[pd.isnull(final_table1['recruiter'])]
    final_table = final_table1.dropna()
    return(final_table)



celgene_base = 'https://jobs.celgene.com/jobs?page='
celgene_home = celgene_base + str(1)
start_word_html = 'totalCount'
stop_word_html = 'languageCounts'
start_word_url = 'https'
stop_word_url = 'lang=en-us'
columns = ['job_pos_title','location','job_category','req_id','summary']
celgenejobs_df = pd.DataFrame(celgenejobsfinal,columns=columns)
pd.options.display.max_colwidth=5000
summary = celgenejobs_df['summary']
results = []
explanation=[]
male=[]
female=[]
celgenejobs_df['result']=resultslist
celgenejobs_df['explanation']=explanationlist
celgenejobs_df['masculine_coded_words']= malelist
celgenejobs_df['feminine_coded_words']=femalelist
conn = pyodbc.connect('DSN=Cloudera-Prod;UID=vmuthukrishnan;PWD=', autocommit = True)
volume=pd.read_sql("select * from exp_workforce_analytics.volume_clean_daily",conn)
feminine_coded_words = [
    "agree",
    "affectionate",
    "child",
    "cheer",
    "collab",
    "commit",
    "communal",
    "compassion",
    "connect",
    "considerate",
    "cooperat",
    "co-operat",
    "depend",
    "emotiona",
    "empath",
    "feel",
    "flatterable",
    "gentle",
    "honest",
    "interpersonal",
    "interdependen",
    "interpersona",
    "inter-personal",
    "inter-dependen",
    "inter-persona",
    "kind",
    "kinship",
    "loyal",
    "modesty",
    "nag",
    "nurtur",
    "pleasant",
    "polite",
    "quiet",
    "respon",
    "sensitiv",
    "submissive",
    "support",
    "sympath",
    "tender",
    "together",
    "trust",
    "understand",
    "warm",
    "whin",
    "enthusias",
    "inclusive",
    "yield",
    "shar"]

masculine_coded_words = [
    "active",
    "adventurous",
    "aggress",
    "ambitio",
    "analy",
    "assert",
    "athlet",
    "autonom",
    "battle",
    "boast",
    "challeng",
    "champion",
    "compet",
    "confident",
    "courag",
    "decid",
    "decision",
    "decisive",
    "defend",
    "determin",
    "domina",
    "dominant",
    "driven",
    "fearless",
    "fight",
    "force",
    "greedy",
    "head-strong",
    "headstrong",
    "hierarch",
    "hostil",
    "implusive",
    "independen",
    "individual",
    "intellect",
    "lead",
    "logic",
    "objective",
    "opinion",
    "outspoken",
    "persist",
    "principle",
    "reckless",
    "self-confiden",
    "self-relian",
    "self-sufficien",
    "selfconfiden",
    "selfrelian",
    "selfsufficien",
    "stubborn",
    "superior",
    "unreasonab"]




page_count = find_num_job_pages(celgene_home,start_word_html,stop_word_html)
job_batch_list = get_job_batch_urls(page_count, celgene_base)
hrefs_dirty = get_all_job_hrefs(job_batch_list)
hrefs_clean = clean_hrefs(hrefs_dirty, start_word_url,stop_word_url)
celgenejobs_df = get_info_from_hrefs(celgenejobs_df,hrefs_clean)
summaryresults(summary)
final_table=join(celgenejobs_df,volume)
pd.options.display.max_colwidth=100
final_table
